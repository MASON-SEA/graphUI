!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).X6Geometry={})}(this,(function(t){"use strict";var e,n;t.Angle=void 0,(e=t.Angle||(t.Angle={})).toDeg=function(t){return 180*t/Math.PI%360},e.toRad=function(t,e=!1){return(e?t:t%360)*Math.PI/180},e.normalize=function(t){return t%360+(t<0?360:0)},t.GeometryUtil=void 0,(n=t.GeometryUtil||(t.GeometryUtil={})).round=function(t,e=0){return Number.isInteger(t)?t:+t.toFixed(e)},n.random=function(t,e){let n,i;if(null==e?(i=null==t?1:t,n=0):(i=e,n=null==t?0:t),i<n){const t=n;n=i,i=t}return Math.floor(Math.random()*(i-n+1)+n)},n.clamp=function(t,e,n){return Number.isNaN(t)?NaN:Number.isNaN(e)||Number.isNaN(n)?0:e<n?t<e?e:t>n?n:t:t<n?n:t>e?e:t},n.snapToGrid=function(t,e){return e*Math.round(t/e)},n.containsPoint=function(t,e){return null!=e&&null!=t&&e.x>=t.x&&e.x<=t.x+t.width&&e.y>=t.y&&e.y<=t.y+t.height},n.squaredLength=function(t,e){const n=t.x-e.x,i=t.y-e.y;return n*n+i*i};class i{valueOf(){return this.toJSON()}toString(){return JSON.stringify(this.toJSON())}}class s extends i{constructor(t,e){super(),this.x=null==t?0:t,this.y=null==e?0:e}round(e=0){return this.x=t.GeometryUtil.round(this.x,e),this.y=t.GeometryUtil.round(this.y,e),this}add(t,e){const n=s.create(t,e);return this.x+=n.x,this.y+=n.y,this}update(t,e){const n=s.create(t,e);return this.x=n.x,this.y=n.y,this}translate(t,e){const n=s.create(t,e);return this.x+=n.x,this.y+=n.y,this}rotate(t,e){const n=s.rotate(this,t,e);return this.x=n.x,this.y=n.y,this}scale(t,e,n=new s){const i=s.create(n);return this.x=i.x+t*(this.x-i.x),this.y=i.y+e*(this.y-i.y),this}closest(t){if(1===t.length)return s.create(t[0]);let e=null,n=1/0;return t.forEach((t=>{const i=this.squaredDistance(t);i<n&&(e=t,n=i)})),e?s.create(e):null}distance(t){return Math.sqrt(this.squaredDistance(t))}squaredDistance(t){const e=s.create(t),n=this.x-e.x,i=this.y-e.y;return n*n+i*i}manhattanDistance(t){const e=s.create(t);return Math.abs(e.x-this.x)+Math.abs(e.y-this.y)}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)||.01}theta(t=new s){const e=s.create(t),n=-(e.y-this.y),i=e.x-this.x;let r=Math.atan2(n,i);return r<0&&(r=2*Math.PI+r),180*r/Math.PI}angleBetween(t,e){if(this.equals(t)||this.equals(e))return NaN;let n=this.theta(e)-this.theta(t);return n<0&&(n+=360),n}vectorAngle(t){return new s(0,0).angleBetween(this,t)}toPolar(t){return this.update(s.toPolar(this,t)),this}changeInAngle(t,e,n=new s){return this.clone().translate(-t,-e).theta(n)-this.theta(n)}adhereToRect(e){return t.GeometryUtil.containsPoint(e,this)||(this.x=Math.min(Math.max(this.x,e.x),e.x+e.width),this.y=Math.min(Math.max(this.y,e.y),e.y+e.height)),this}bearing(e){const n=s.create(e),i=t.Angle.toRad(this.y),r=t.Angle.toRad(n.y),o=this.x,h=n.x,l=t.Angle.toRad(h-o),u=Math.sin(l)*Math.cos(r),a=Math.cos(i)*Math.sin(r)-Math.sin(i)*Math.cos(r)*Math.cos(l);let c=t.Angle.toDeg(Math.atan2(u,a))-22.5;return c<0&&(c+=360),c=parseInt(c/45,10),["NE","E","SE","S","SW","W","NW","N"][c]}cross(t,e){if(null!=t&&null!=e){const n=s.create(t),i=s.create(e);return(i.x-this.x)*(n.y-this.y)-(i.y-this.y)*(n.x-this.x)}return NaN}dot(t){const e=s.create(t);return this.x*e.x+this.y*e.y}diff(t,e){if("number"==typeof t)return new s(this.x-t,this.y-e);const n=s.create(t);return new s(this.x-n.x,this.y-n.y)}lerp(t,e){const n=s.create(t);return new s((1-e)*this.x+e*n.x,(1-e)*this.y+e*n.y)}normalize(t=1){const e=t/this.magnitude();return this.scale(e,e)}move(e,n){const i=s.create(e),r=t.Angle.toRad(i.theta(this));return this.translate(Math.cos(r)*n,-Math.sin(r)*n)}reflection(t){return s.create(t).move(this,this.distance(t))}snapToGrid(e,n){return this.x=t.GeometryUtil.snapToGrid(this.x,e),this.y=t.GeometryUtil.snapToGrid(this.y,null==n?e:n),this}equals(t){const e=s.create(t);return null!=e&&e.x===this.x&&e.y===this.y}clone(){return s.clone(this)}toJSON(){return s.toJSON(this)}serialize(){return`${this.x} ${this.y}`}}!function(t){t.isPoint=function(e){return null!=e&&e instanceof t}}(s||(s={})),function(t){t.isPointLike=function(t){return null!=t&&"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y},t.isPointData=function(t){return null!=t&&Array.isArray(t)&&2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]}}(s||(s={})),function(e){function n(t){return e.isPoint(t)?new e(t.x,t.y):Array.isArray(t)?new e(t[0],t[1]):new e(t.x,t.y)}function i(t,e){return t===e||null!=t&&null!=e&&(t.x===e.x&&t.y===e.y)}function s(t,i,s,r=new e){const o=n(t),h=n(r),l=o.x-h.x,u=o.y-h.y,a=u*i+l*s;return new e(l*i-u*s+h.x,a+h.y)}e.create=function(t,i){return null==t||"number"==typeof t?new e(t,i):n(t)},e.clone=n,e.toJSON=function(t){return e.isPoint(t)?{x:t.x,y:t.y}:Array.isArray(t)?{x:t[0],y:t[1]}:{x:t.x,y:t.y}},e.fromPolar=function(i,s,r=new e){let o=Math.abs(i*Math.cos(s)),h=Math.abs(i*Math.sin(s));const l=n(r),u=t.Angle.normalize(t.Angle.toDeg(s));return u<90?h=-h:u<180?(o=-o,h=-h):u<270&&(o=-o),new e(l.x+o,l.y+h)},e.toPolar=function(i,s=new e){const r=n(i),o=n(s),h=r.x-o.x,l=r.y-o.y;return new e(Math.sqrt(h*h+l*l),t.Angle.toRad(o.theta(r)))},e.equals=i,e.equalPoints=function(t,e){if(null==t&&null!=e||null!=t&&null==e||null!=t&&null!=e&&t.length!==e.length)return!1;if(null!=t&&null!=e)for(let n=0,s=t.length;n<s;n+=1)if(!i(t[n],e[n]))return!1;return!0},e.random=function(n,i,s,r){return new e(t.GeometryUtil.random(n,i),t.GeometryUtil.random(s,r))},e.rotate=function(e,n,i){const r=t.Angle.toRad(t.Angle.normalize(-n)),o=Math.sin(r);return s(e,Math.cos(r),o,i)},e.rotateEx=s}(s||(s={}));class r extends i{get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get origin(){return new s(this.x,this.y)}get topLeft(){return new s(this.x,this.y)}get topCenter(){return new s(this.x+this.width/2,this.y)}get topRight(){return new s(this.x+this.width,this.y)}get center(){return new s(this.x+this.width/2,this.y+this.height/2)}get bottomLeft(){return new s(this.x,this.y+this.height)}get bottomCenter(){return new s(this.x+this.width/2,this.y+this.height)}get bottomRight(){return new s(this.x+this.width,this.y+this.height)}get corner(){return new s(this.x+this.width,this.y+this.height)}get rightMiddle(){return new s(this.x+this.width,this.y+this.height/2)}get leftMiddle(){return new s(this.x,this.y+this.height/2)}get topLine(){return new o(this.topLeft,this.topRight)}get rightLine(){return new o(this.topRight,this.bottomRight)}get bottomLine(){return new o(this.bottomLeft,this.bottomRight)}get leftLine(){return new o(this.topLeft,this.bottomLeft)}constructor(t,e,n,i){super(),this.x=null==t?0:t,this.y=null==e?0:e,this.width=null==n?0:n,this.height=null==i?0:i}getOrigin(){return this.origin}getTopLeft(){return this.topLeft}getTopCenter(){return this.topCenter}getTopRight(){return this.topRight}getCenter(){return this.center}getCenterX(){return this.x+this.width/2}getCenterY(){return this.y+this.height/2}getBottomLeft(){return this.bottomLeft}getBottomCenter(){return this.bottomCenter}getBottomRight(){return this.bottomRight}getCorner(){return this.corner}getRightMiddle(){return this.rightMiddle}getLeftMiddle(){return this.leftMiddle}getTopLine(){return this.topLine}getRightLine(){return this.rightLine}getBottomLine(){return this.bottomLine}getLeftLine(){return this.leftLine}bbox(e){if(!e)return this.clone();const n=t.Angle.toRad(e),i=Math.abs(Math.sin(n)),s=Math.abs(Math.cos(n)),o=this.width*s+this.height*i,h=this.width*i+this.height*s;return new r(this.x+(this.width-o)/2,this.y+(this.height-h)/2,o,h)}round(e=0){return this.x=t.GeometryUtil.round(this.x,e),this.y=t.GeometryUtil.round(this.y,e),this.width=t.GeometryUtil.round(this.width,e),this.height=t.GeometryUtil.round(this.height,e),this}add(t,e,n,i){const s=r.create(t,e,n,i),o=Math.min(this.x,s.x),h=Math.min(this.y,s.y),l=Math.max(this.x+this.width,s.x+s.width),u=Math.max(this.y+this.height,s.y+s.height);return this.x=o,this.y=h,this.width=l-o,this.height=u-h,this}update(t,e,n,i){const s=r.create(t,e,n,i);return this.x=s.x,this.y=s.y,this.width=s.width,this.height=s.height,this}inflate(t,e){const n=t,i=null!=e?e:t;return this.x-=n,this.y-=i,this.width+=2*n,this.height+=2*i,this}snapToGrid(t,e){const n=this.origin.snapToGrid(t,e),i=this.corner.snapToGrid(t,e);return this.x=n.x,this.y=n.y,this.width=i.x-n.x,this.height=i.y-n.y,this}translate(t,e){const n=s.create(t,e);return this.x+=n.x,this.y+=n.y,this}scale(t,e,n=new s){const i=this.origin.scale(t,e,n);return this.x=i.x,this.y=i.y,this.width*=t,this.height*=e,this}rotate(e,n=this.getCenter()){if(0!==e){const i=t.Angle.toRad(e),o=Math.cos(i),h=Math.sin(i);let l=this.getOrigin(),u=this.getTopRight(),a=this.getBottomRight(),c=this.getBottomLeft();l=s.rotateEx(l,o,h,n),u=s.rotateEx(u,o,h,n),a=s.rotateEx(a,o,h,n),c=s.rotateEx(c,o,h,n);const g=new r(l.x,l.y,0,0);g.add(u.x,u.y,0,0),g.add(a.x,a.y,0,0),g.add(c.x,c.y,0,0),this.update(g)}return this}rotate90(){const t=(this.width-this.height)/2;this.x+=t,this.y-=t;const e=this.width;return this.width=this.height,this.height=e,this}moveAndExpand(t){const e=r.clone(t);return this.x+=e.x||0,this.y+=e.y||0,this.width+=e.width||0,this.height+=e.height||0,this}getMaxScaleToFit(t,e=this.center){const n=r.clone(t),i=e.x,s=e.y;let o=1/0,h=1/0,l=1/0,u=1/0,a=1/0,c=1/0,g=1/0,d=1/0;const f=n.topLeft;f.x<i&&(o=(this.x-i)/(f.x-i)),f.y<s&&(a=(this.y-s)/(f.y-s));const p=n.bottomRight;p.x>i&&(h=(this.x+this.width-i)/(p.x-i)),p.y>s&&(c=(this.y+this.height-s)/(p.y-s));const y=n.topRight;y.x>i&&(l=(this.x+this.width-i)/(y.x-i)),y.y<s&&(g=(this.y-s)/(y.y-s));const m=n.bottomLeft;return m.x<i&&(u=(this.x-i)/(m.x-i)),m.y>s&&(d=(this.y+this.height-s)/(m.y-s)),{sx:Math.min(o,h,l,u),sy:Math.min(a,c,g,d)}}getMaxUniformScaleToFit(t,e=this.center){const n=this.getMaxScaleToFit(t,e);return Math.min(n.sx,n.sy)}containsPoint(e,n){return t.GeometryUtil.containsPoint(this,s.create(e,n))}containsRect(t,e,n,i){const s=r.create(t,e,n,i),o=this.x,h=this.y,l=this.width,u=this.height,a=s.x,c=s.y,g=s.width,d=s.height;return 0!==l&&0!==u&&0!==g&&0!==d&&(a>=o&&c>=h&&a+g<=o+l&&c+d<=h+u)}intersectsWithLine(t){const e=[this.topLine,this.rightLine,this.bottomLine,this.leftLine],n=[],i=[];return e.forEach((e=>{const s=t.intersectsWithLine(e);null!==s&&i.indexOf(s.toString())<0&&(n.push(s),i.push(s.toString()))})),n.length>0?n:null}intersectsWithLineFromCenterToPoint(t,e){const n=s.clone(t),i=this.center;let r=null;null!=e&&0!==e&&n.rotate(e,i);const h=[this.topLine,this.rightLine,this.bottomLine,this.leftLine],l=new o(i,n);for(let t=h.length-1;t>=0;t-=1){const e=h[t].intersectsWithLine(l);if(null!==e){r=e;break}}return r&&null!=e&&0!==e&&r.rotate(-e,i),r}intersectsWithRect(t,e,n,i){const s=r.create(t,e,n,i);if(!this.isIntersectWithRect(s))return null;const o=this.origin,h=this.corner,l=s.origin,u=s.corner,a=Math.max(o.x,l.x),c=Math.max(o.y,l.y);return new r(a,c,Math.min(h.x,u.x)-a,Math.min(h.y,u.y)-c)}isIntersectWithRect(t,e,n,i){const s=r.create(t,e,n,i),o=this.origin,h=this.corner,l=s.origin,u=s.corner;return!(u.x<=o.x||u.y<=o.y||l.x>=h.x||l.y>=h.y)}normalize(){let t=this.x,e=this.y,n=this.width,i=this.height;return this.width<0&&(t=this.x+this.width,n=-this.width),this.height<0&&(e=this.y+this.height,i=-this.height),this.x=t,this.y=e,this.width=n,this.height=i,this}union(t){const e=r.clone(t),n=this.origin,i=this.corner,s=e.origin,o=e.corner,h=Math.min(n.x,s.x),l=Math.min(n.y,s.y),u=Math.max(i.x,o.x),a=Math.max(i.y,o.y);return new r(h,l,u-h,a-l)}getNearestSideToPoint(t){const e=s.clone(t),n=e.x-this.x,i=this.x+this.width-e.x,r=e.y-this.y;let o=n,h="left";return i<o&&(o=i,h="right"),r<o&&(o=r,h="top"),this.y+this.height-e.y<o&&(h="bottom"),h}getNearestPointToPoint(t){const e=s.clone(t);if(this.containsPoint(e)){const t=this.getNearestSideToPoint(e);if("left"===t)return new s(this.x,e.y);if("top"===t)return new s(e.x,this.y);if("right"===t)return new s(this.x+this.width,e.y);if("bottom"===t)return new s(e.x,this.y+this.height)}return e.adhereToRect(this)}equals(t){return null!=t&&t.x===this.x&&t.y===this.y&&t.width===this.width&&t.height===this.height}clone(){return new r(this.x,this.y,this.width,this.height)}toJSON(){return{x:this.x,y:this.y,width:this.width,height:this.height}}serialize(){return`${this.x} ${this.y} ${this.width} ${this.height}`}}!function(t){t.isRectangle=function(e){return null!=e&&e instanceof t}}(r||(r={})),function(t){t.isRectangleLike=function(t){return null!=t&&"object"==typeof t&&"number"==typeof t.x&&"number"==typeof t.y&&"number"==typeof t.width&&"number"==typeof t.height}}(r||(r={})),function(t){function e(e){return t.isRectangle(e)?e.clone():Array.isArray(e)?new t(e[0],e[1],e[2],e[3]):new t(e.x,e.y,e.width,e.height)}t.create=function(n,i,s,r){return null==n||"number"==typeof n?new t(n,i,s,r):e(n)},t.clone=e,t.fromEllipse=function(e){return new t(e.x-e.a,e.y-e.b,2*e.a,2*e.b)},t.fromSize=function(e){return new t(0,0,e.width,e.height)},t.fromPositionAndSize=function(e,n){return new t(e.x,e.y,n.width,n.height)}}(r||(r={}));class o extends i{get center(){return new s((this.start.x+this.end.x)/2,(this.start.y+this.end.y)/2)}constructor(t,e,n,i){super(),"number"==typeof t&&"number"==typeof e?(this.start=new s(t,e),this.end=new s(n,i)):(this.start=s.create(t),this.end=s.create(e))}getCenter(){return this.center}round(t=0){return this.start.round(t),this.end.round(t),this}translate(t,e){return"number"==typeof t?(this.start.translate(t,e),this.end.translate(t,e)):(this.start.translate(t),this.end.translate(t)),this}rotate(t,e){return this.start.rotate(t,e),this.end.rotate(t,e),this}scale(t,e,n){return this.start.scale(t,e,n),this.end.scale(t,e,n),this}length(){return Math.sqrt(this.squaredLength())}squaredLength(){const t=this.start.x-this.end.x,e=this.start.y-this.end.y;return t*t+e*e}setLength(t){const e=this.length();if(!e)return this;const n=t/e;return this.scale(n,n,this.start)}parallel(t){const e=this.clone();if(!e.isDifferentiable())return e;const{start:n,end:i}=e,s=n.clone().rotate(270,i),r=i.clone().rotate(90,n);return n.move(r,t),i.move(s,t),e}vector(){return new s(this.end.x-this.start.x,this.end.y-this.start.y)}angle(){const t=new s(this.start.x+1,this.start.y);return this.start.angleBetween(this.end,t)}bbox(){const t=Math.min(this.start.x,this.end.x),e=Math.min(this.start.y,this.end.y),n=Math.max(this.start.x,this.end.x),i=Math.max(this.start.y,this.end.y);return new r(t,e,n-t,i-e)}bearing(){return this.start.bearing(this.end)}closestPoint(t){return this.pointAt(this.closestPointNormalizedLength(t))}closestPointLength(t){return this.closestPointNormalizedLength(t)*this.length()}closestPointTangent(t){return this.tangentAt(this.closestPointNormalizedLength(t))}closestPointNormalizedLength(t){const e=this.vector().dot(new o(this.start,t).vector()),n=Math.min(1,Math.max(0,e/this.squaredLength()));return Number.isNaN(n)?0:n}pointAt(t){const e=this.start,n=this.end;return t<=0?e.clone():t>=1?n.clone():e.lerp(n,t)}pointAtLength(t){const e=this.start,n=this.end;let i=!0;t<0&&(i=!1,t=-t);const s=this.length();if(t>=s)return i?n.clone():e.clone();const r=(i?t:s-t)/s;return this.pointAt(r)}divideAt(t){const e=this.pointAt(t);return[new o(this.start,e),new o(e,this.end)]}divideAtLength(t){const e=this.pointAtLength(t);return[new o(this.start,e),new o(e,this.end)]}containsPoint(t){const e=this.start,n=this.end;if(0!==e.cross(t,n))return!1;const i=this.length();return!(new o(e,t).length()>i)&&!(new o(t,n).length()>i)}intersect(t,e){const n=t.intersectsWithLine(this,e);return n?Array.isArray(n)?n:[n]:null}intersectsWithLine(t){const e=new s(this.end.x-this.start.x,this.end.y-this.start.y),n=new s(t.end.x-t.start.x,t.end.y-t.start.y),i=e.x*n.y-e.y*n.x,r=new s(t.start.x-this.start.x,t.start.y-this.start.y),o=r.x*n.y-r.y*n.x,h=r.x*e.y-r.y*e.x;if(0===i||o*i<0||h*i<0)return null;if(i>0){if(o>i||h>i)return null}else if(o<i||h<i)return null;return new s(this.start.x+o*e.x/i,this.start.y+o*e.y/i)}isDifferentiable(){return!this.start.equals(this.end)}pointOffset(t){const e=s.clone(t),n=this.start,i=this.end;return((i.x-n.x)*(e.y-n.y)-(i.y-n.y)*(e.x-n.x))/this.length()}pointSquaredDistance(t,e){const n=s.create(t,e);return this.closestPoint(n).squaredDistance(n)}pointDistance(t,e){const n=s.create(t,e);return this.closestPoint(n).distance(n)}tangentAt(t){if(!this.isDifferentiable())return null;const e=this.start,n=this.end,i=this.pointAt(t),s=new o(e,n);return s.translate(i.x-e.x,i.y-e.y),s}tangentAtLength(t){if(!this.isDifferentiable())return null;const e=this.start,n=this.end,i=this.pointAtLength(t),s=new o(e,n);return s.translate(i.x-e.x,i.y-e.y),s}relativeCcw(t,e){const n=s.create(t,e);let i=n.x-this.start.x,r=n.y-this.start.y;const o=this.end.x-this.start.x,h=this.end.y-this.start.y;let l=i*h-r*o;return 0===l&&(l=i*o+r*h,l>0&&(i-=o,r-=h,l=i*o+r*h,l<0&&(l=0))),l<0?-1:l>0?1:0}equals(t){return null!=t&&this.start.x===t.start.x&&this.start.y===t.start.y&&this.end.x===t.end.x&&this.end.y===t.end.y}clone(){return new o(this.start,this.end)}toJSON(){return{start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){return[this.start.serialize(),this.end.serialize()].join(" ")}}!function(t){t.isLine=function(e){return null!=e&&e instanceof t}}(o||(o={}));class h extends i{get center(){return new s(this.x,this.y)}constructor(t,e,n,i){super(),this.x=null==t?0:t,this.y=null==e?0:e,this.a=null==n?0:n,this.b=null==i?0:i}bbox(){return r.fromEllipse(this)}getCenter(){return this.center}inflate(t,e){const n=t,i=null!=e?e:t;return this.a+=2*n,this.b+=2*i,this}normalizedDistance(t,e){const n=s.create(t,e),i=n.x-this.x,r=n.y-this.y,o=this.a,h=this.b;return i*i/(o*o)+r*r/(h*h)}containsPoint(t,e){return this.normalizedDistance(t,e)<=1}intersectsWithLine(t){const e=[],n=this.a,i=this.b,r=t.start,o=t.end,h=t.vector(),l=r.diff(new s(this.x,this.y)),u=new s(h.x/(n*n),h.y/(i*i)),a=new s(l.x/(n*n),l.y/(i*i)),c=h.dot(u),g=h.dot(a),d=g*g-c*(l.dot(a)-1);if(d<0)return null;if(d>0){const t=Math.sqrt(d),n=(-g-t)/c,i=(-g+t)/c;if((n<0||n>1)&&(i<0||i>1))return null;n>=0&&n<=1&&e.push(r.lerp(o,n)),i>=0&&i<=1&&e.push(r.lerp(o,i))}else{const t=-g/c;if(!(t>=0&&t<=1))return null;e.push(r.lerp(o,t))}return e}intersectsWithLineFromCenterToPoint(t,e=0){const n=s.clone(t);e&&n.rotate(e,this.getCenter());const i=n.x-this.x,r=n.y-this.y;let o;if(0===i)return o=this.bbox().getNearestPointToPoint(n),e?o.rotate(-e,this.getCenter()):o;const h=r/i,l=h*h,u=this.a*this.a,a=this.b*this.b;let c=Math.sqrt(1/(1/u+l/a));c=i<0?-c:c;const g=h*c;return o=new s(this.x+c,this.y+g),e?o.rotate(-e,this.getCenter()):o}tangentTheta(t){const e=s.clone(t),n=e.x,i=e.y,r=this.a,o=this.b,h=this.bbox().center,l=h.x,u=h.y,a=n>h.x+r/2,c=n<h.x-r/2;let g,d;return a||c?(d=n>h.x?i-30:i+30,g=r*r/(n-l)-r*r*(i-u)*(d-u)/(o*o*(n-l))+l):(g=i>h.y?n+30:n-30,d=o*o/(i-u)-o*o*(n-l)*(g-l)/(r*r*(i-u))+u),new s(g,d).theta(e)}scale(t,e){return this.a*=t,this.b*=e,this}rotate(t,e){const n=r.fromEllipse(this);n.rotate(t,e);const i=h.fromRect(n);return this.a=i.a,this.b=i.b,this.x=i.x,this.y=i.y,this}translate(t,e){const n=s.create(t,e);return this.x+=n.x,this.y+=n.y,this}equals(t){return null!=t&&t.x===this.x&&t.y===this.y&&t.a===this.a&&t.b===this.b}clone(){return new h(this.x,this.y,this.a,this.b)}toJSON(){return{x:this.x,y:this.y,a:this.a,b:this.b}}serialize(){return`${this.x} ${this.y} ${this.a} ${this.b}`}}!function(t){t.isEllipse=function(e){return null!=e&&e instanceof t}}(h||(h={})),function(t){function e(e){return t.isEllipse(e)?e.clone():Array.isArray(e)?new t(e[0],e[1],e[2],e[3]):new t(e.x,e.y,e.a,e.b)}t.create=function(n,i,s,r){return null==n||"number"==typeof n?new t(n,i,s,r):e(n)},t.parse=e,t.fromRect=function(e){const n=e.center;return new t(n.x,n.y,e.width/2,e.height/2)}}(h||(h={}));const l=new RegExp("^[\\s\\dLMCZz,.]*$");function u(t){return"string"==typeof t&&l.test(t)}function a(t,e){return(t%e+e)%e}function c(t,e={}){const n=[];return t&&t.length&&t.forEach((t=>{Array.isArray(t)?n.push({x:t[0],y:t[1]}):n.push({x:t.x,y:t.y})})),function(t,e,n,i,r){const o=[],h=t[t.length-1],l=null!=e&&e>0,u=e||0;if(i&&l){const e=(t=t.slice())[0],n=new s(h.x+(e.x-h.x)/2,h.y+(e.y-h.y)/2);t.splice(0,0,n)}let c=t[0],g=1;for(n?o.push("M",c.x,c.y):o.push("L",c.x,c.y);g<(i?t.length:t.length-1);){let e=t[a(g,t.length)],n=c.x-e.x,i=c.y-e.y;if(l&&(0!==n||0!==i)&&(null==r||r.indexOf(g-1)<0)){let r=Math.sqrt(n*n+i*i);const h=n*Math.min(u,r/2)/r,l=i*Math.min(u,r/2)/r,c=e.x+h,d=e.y+l;o.push("L",c,d);let f=t[a(g+1,t.length)];for(;g<t.length-2&&0===Math.round(f.x-e.x)&&0===Math.round(f.y-e.y);)f=t[a(g+2,t.length)],g+=1;n=f.x-e.x,i=f.y-e.y,r=Math.max(1,Math.sqrt(n*n+i*i));const p=n*Math.min(u,r/2)/r,y=i*Math.min(u,r/2)/r,m=e.x+p,x=e.y+y;o.push("Q",e.x,e.y,m,x),e=new s(m,x)}else o.push("L",e.x,e.y);c=e,g+=1}return i?o.push("Z"):o.push("L",h.x,h.y),o.map((t=>"string"==typeof t?t:+t.toFixed(3))).join(" ")}(n,e.round,null==e.initialMove||e.initialMove,e.close,e.exclude)}function g(t,e,n,i,s=0,r=0,o=0,h,l){if(0===n||0===i)return[];h-=t,l-=e,n=Math.abs(n),i=Math.abs(i);const u=-h/2,a=-l/2,c=Math.cos(s*Math.PI/180),g=Math.sin(s*Math.PI/180),d=c*u+g*a,f=-1*g*u+c*a,p=d*d,y=f*f,m=n*n,x=i*i,w=p/m+y/x;let P;if(w>1)n=Math.sqrt(w)*n,i=Math.sqrt(w)*i,P=0;else{let t=1;r===o&&(t=-1),P=t*Math.sqrt((m*x-m*y-x*p)/(m*y+x*p))}const b=P*n*f/i,A=-1*P*i*d/n,S=c*b-g*A+h/2,v=g*b+c*A+l/2;let L=Math.atan2((f-A)/i,(d-b)/n)-Math.atan2(0,1),M=L>=0?L:2*Math.PI+L;L=Math.atan2((-f-A)/i,(-d-b)/n)-Math.atan2((f-A)/i,(d-b)/n);let T=L>=0?L:2*Math.PI+L;0===o&&T>0?T-=2*Math.PI:0!==o&&T<0&&(T+=2*Math.PI);const N=2*T/Math.PI,q=Math.ceil(N<0?-1*N:N),C=T/q,z=8/3*Math.sin(C/4)*Math.sin(C/4)/Math.sin(C/2),E=c*n,O=c*i,D=g*n,I=g*i;let R=Math.cos(M),J=Math.sin(M),G=-z*(E*J+I*R),U=-z*(D*J-O*R),$=0,k=0;const W=[];for(let n=0;n<q;n+=1){M+=C,R=Math.cos(M),J=Math.sin(M),$=E*R-I*J+S,k=D*R+O*J+v;const i=-z*(E*J+I*R),s=-z*(D*J-O*R),r=6*n;W[r]=Number(G+t),W[r+1]=Number(U+e),W[r+2]=Number($-i+t),W[r+3]=Number(k-s+e),W[r+4]=Number($+t),W[r+5]=Number(k+e),G=$+i,U=k+s}return W.map((t=>+t.toFixed(2)))}function d(t,e,n,i,s=0,r=0,o=0,h,l){const u=[],a=g(t,e,n,i,s,r,o,h,l);if(null!=a)for(let t=0,e=a.length;t<e;t+=6)u.push("C",a[t],a[t+1],a[t+2],a[t+3],a[t+4],a[t+5]);return u.join(" ")}class f extends i{get start(){return this.points[0]||null}get end(){return this.points[this.points.length-1]||null}constructor(t){if(super(),null!=t){if("string"==typeof t)return f.parse(t);this.points=t.map((t=>s.create(t)))}else this.points=[]}scale(t,e,n=new s){return this.points.forEach((i=>i.scale(t,e,n))),this}rotate(t,e){return this.points.forEach((n=>n.rotate(t,e))),this}translate(t,e){const n=s.create(t,e);return this.points.forEach((t=>t.translate(n.x,n.y))),this}round(t=0){return this.points.forEach((e=>e.round(t))),this}bbox(){if(0===this.points.length)return new r;let t=1/0,e=-1/0,n=1/0,i=-1/0;const s=this.points;for(let r=0,o=s.length;r<o;r+=1){const o=s[r],h=o.x,l=o.y;h<t&&(t=h),h>e&&(e=h),l<n&&(n=l),l>i&&(i=l)}return new r(t,n,e-t,i-n)}closestPoint(t){const e=this.closestPointLength(t);return this.pointAtLength(e)}closestPointLength(t){const e=this.points,n=e.length;if(0===n||1===n)return 0;let i=0,s=0,r=1/0;for(let h=0,l=n-1;h<l;h+=1){const n=new o(e[h],e[h+1]),l=n.length(),u=n.closestPointNormalizedLength(t),a=n.pointAt(u).squaredDistance(t);a<r&&(r=a,s=i+u*l),i+=l}return s}closestPointNormalizedLength(t){const e=this.length();if(0===e)return 0;return this.closestPointLength(t)/e}closestPointTangent(t){const e=this.closestPointLength(t);return this.tangentAtLength(e)}containsPoint(t){if(0===this.points.length)return!1;const e=s.clone(t),n=e.x,i=e.y,r=this.points,h=r.length;let l=h-1,u=0;for(let a=0;a<h;a+=1){const h=r[l],c=r[a];if(e.equals(h))return!0;const g=new o(h,c);if(g.containsPoint(t))return!0;if(i<=h.y&&i>c.y||i>h.y&&i<=c.y){const e=h.x-n>c.x-n?h.x-n:c.x-n;if(e>=0){const r=new s(n+e,i),h=new o(t,r);g.intersectsWithLine(h)&&(u+=1)}}l=a}return u%2==1}intersectsWithLine(t){const e=[];for(let n=0,i=this.points.length-1;n<i;n+=1){const i=this.points[n],s=this.points[n+1],r=t.intersectsWithLine(new o(i,s));r&&e.push(r)}return e.length>0?e:null}isDifferentiable(){for(let t=0,e=this.points.length-1;t<e;t+=1){const e=this.points[t],n=this.points[t+1];if(new o(e,n).isDifferentiable())return!0}return!1}length(){let t=0;for(let e=0,n=this.points.length-1;e<n;e+=1){const n=this.points[e],i=this.points[e+1];t+=n.distance(i)}return t}pointAt(t){const e=this.points,n=e.length;if(0===n)return null;if(1===n)return e[0].clone();if(t<=0)return e[0].clone();if(t>=1)return e[n-1].clone();const i=this.length()*t;return this.pointAtLength(i)}pointAtLength(t){const e=this.points,n=e.length;if(0===n)return null;if(1===n)return e[0].clone();let i=!0;t<0&&(i=!1,t=-t);let s=0;for(let r=0,h=n-1;r<h;r+=1){const n=i?r:h-1-r,l=e[n],u=e[n+1],a=new o(l,u),c=l.distance(u);if(t<=s+c)return a.pointAtLength((i?1:-1)*(t-s));s+=c}return(i?e[n-1]:e[0]).clone()}tangentAt(t){const e=this.points.length;if(0===e||1===e)return null;t<0&&(t=0),t>1&&(t=1);const n=this.length()*t;return this.tangentAtLength(n)}tangentAtLength(t){const e=this.points,n=e.length;if(0===n||1===n)return null;let i,s=!0;t<0&&(s=!1,t=-t);let r=0;for(let h=0,l=n-1;h<l;h+=1){const n=s?h:l-1-h,u=e[n],a=e[n+1],c=new o(u,a),g=u.distance(a);if(c.isDifferentiable()){if(t<=r+g)return c.tangentAtLength((s?1:-1)*(t-r));i=c}r+=g}if(i){const t=s?1:0;return i.tangentAt(t)}return null}simplify(t={}){const e=this.points;if(e.length<3)return this;const n=t.threshold||0;let i=0;for(;e[i+2];){const t=i+1,s=i+2,r=e[i],h=e[t],l=e[s];new o(r,l).closestPoint(h).distance(h)<=n?e.splice(t,1):i+=1}return this}toHull(){const t=this.points,e=t.length;if(0===e)return new f;let n=t[0];for(let i=1;i<e;i+=1)(t[i].y<n.y||t[i].y===n.y&&t[i].x>n.x)&&(n=t[i]);const i=[];for(let s=0;s<e;s+=1){let e=n.theta(t[s]);0===e&&(e=360),i.push([t[s],s,e])}if(i.sort(((t,e)=>{let n=t[2]-e[2];return 0===n&&(n=e[1]-t[1]),n})),i.length>2){const t=i[i.length-1];i.unshift(t)}const s={},r=[],o=t=>`${t[0].toString()}@${t[1]}`;for(;0!==i.length;){const t=i.pop(),e=t[0];if(s[o(t)])continue;let n=!1;for(;!n;)if(r.length<2)r.push(t),n=!0;else{const h=r.pop(),l=h[0],u=r.pop(),a=u[0],c=a.cross(l,e);if(c<0)r.push(u),r.push(h),r.push(t),n=!0;else if(0===c){const t=1e-10,n=l.angleBetween(a,e);Math.abs(n-180)<t||l.equals(e)||a.equals(l)?(s[o(h)]=l,r.push(u)):Math.abs((n+1)%360-1)<t&&(r.push(u),i.push(h))}else s[o(h)]=l,r.push(u)}}let h;r.length>2&&r.pop();let l=-1;for(let t=0,e=r.length;t<e;t+=1){const e=r[t][1];(void 0===h||e<h)&&(h=e,l=t)}let u=[];if(l>0){const t=r.slice(l),e=r.slice(0,l);u=t.concat(e)}else u=r;const a=[];for(let t=0,e=u.length;t<e;t+=1)a.push(u[t][0]);return new f(a)}equals(t){return null!=t&&(t.points.length===this.points.length&&t.points.every(((t,e)=>t.equals(this.points[e]))))}clone(){return new f(this.points.map((t=>t.clone())))}toJSON(){return this.points.map((t=>t.toJSON()))}serialize(){return this.points.map((t=>`${t.serialize()}`)).join(" ")}}!function(t){t.isPolyline=function(e){return null!=e&&e instanceof t}}(f||(f={})),function(t){t.parse=function(e){const n=e.trim();if(""===n)return new t;const i=[],s=n.split(/\s*,\s*|\s+/);for(let t=0,e=s.length;t<e;t+=2)i.push({x:+s[t],y:+s[t+1]});return new t(i)}}(f||(f={}));class p extends i{constructor(t,e,n,i){super(),this.PRECISION=3,this.start=s.create(t),this.controlPoint1=s.create(e),this.controlPoint2=s.create(n),this.end=s.create(i)}bbox(){const t=this.start,e=this.controlPoint1,n=this.controlPoint2,i=this.end,s=t.x,o=t.y,h=e.x,l=e.y,u=n.x,a=n.y,c=i.x,g=i.y,d=[],f=[[],[]];let p,y,m,x,w,P,b,A,S,v,L;for(let t=0;t<2;t+=1)if(0===t?(y=6*s-12*h+6*u,p=-3*s+9*h-9*u+3*c,m=3*h-3*s):(y=6*o-12*l+6*a,p=-3*o+9*l-9*a+3*g,m=3*l-3*o),Math.abs(p)<1e-12){if(Math.abs(y)<1e-12)continue;x=-m/y,x>0&&x<1&&d.push(x)}else b=y*y-4*m*p,A=Math.sqrt(b),b<0||(w=(-y+A)/(2*p),w>0&&w<1&&d.push(w),P=(-y-A)/(2*p),P>0&&P<1&&d.push(P));let M=d.length;const T=M;for(;M;)M-=1,x=d[M],L=1-x,S=L*L*L*s+3*L*L*x*h+3*L*x*x*u+x*x*x*c,f[0][M]=S,v=L*L*L*o+3*L*L*x*l+3*L*x*x*a+x*x*x*g,f[1][M]=v;d[T]=0,d[T+1]=1,f[0][T]=s,f[1][T]=o,f[0][T+1]=c,f[1][T+1]=g,d.length=T+2,f[0].length=T+2,f[1].length=T+2;const N=Math.min.apply(null,f[0]),q=Math.min.apply(null,f[1]),C=Math.max.apply(null,f[0]),z=Math.max.apply(null,f[1]);return new r(N,q,C-N,z-q)}closestPoint(t,e={}){return this.pointAtT(this.closestPointT(t,e))}closestPointLength(t,e={}){const n=this.getOptions(e);return this.lengthAtT(this.closestPointT(t,n),n)}closestPointNormalizedLength(t,e={}){const n=this.getOptions(e),i=this.closestPointLength(t,n);if(!i)return 0;const s=this.length(n);return 0===s?0:i/s}closestPointT(t,e={}){const n=this.getPrecision(e),i=this.getDivisions(e),s=Math.pow(10,-n);let r=null,o=0,h=0,l=0,u=0,a=0,c=null;const g=i.length;let d=g>0?1/g:0;for(i.forEach(((e,n)=>{const i=e.start.distance(t),s=e.end.distance(t),g=i+s;(null==c||g<c)&&(r=e,o=n*d,h=(n+1)*d,l=i,u=s,c=g,a=e.endpointDistance())}));;){const e=l?Math.abs(l-u)/l:0,n=null!=u?Math.abs(l-u)/u:0;if(e<s||n<s||(!l||l<a*s||(!u||u<a*s)))return l<=u?o:h;const i=r.divide(.5);d/=2;const c=i[0].start.distance(t),g=i[0].end.distance(t),f=c+g,p=i[1].start.distance(t),y=i[1].end.distance(t);f<=p+y?(r=i[0],h-=d,l=c,u=g):(r=i[1],o+=d,l=p,u=y)}}closestPointTangent(t,e={}){return this.tangentAtT(this.closestPointT(t,e))}containsPoint(t,e={}){return this.toPolyline(e).containsPoint(t)}divideAt(t,e={}){if(t<=0)return this.divideAtT(0);if(t>=1)return this.divideAtT(1);const n=this.tAt(t,e);return this.divideAtT(n)}divideAtLength(t,e={}){const n=this.tAtLength(t,e);return this.divideAtT(n)}divide(t){return this.divideAtT(t)}divideAtT(t){const e=this.start,n=this.controlPoint1,i=this.controlPoint2,s=this.end;if(t<=0)return[new p(e,e,e,e),new p(e,n,i,s)];if(t>=1)return[new p(e,n,i,s),new p(s,s,s,s)];const r=this.getSkeletonPoints(t),o=r.startControlPoint1,h=r.startControlPoint2,l=r.divider,u=r.dividerControlPoint1,a=r.dividerControlPoint2;return[new p(e,o,h,l),new p(l,u,a,s)]}endpointDistance(){return this.start.distance(this.end)}getSkeletonPoints(t){const e=this.start,n=this.controlPoint1,i=this.controlPoint2,s=this.end;if(t<=0)return{startControlPoint1:e.clone(),startControlPoint2:e.clone(),divider:e.clone(),dividerControlPoint1:n.clone(),dividerControlPoint2:i.clone()};if(t>=1)return{startControlPoint1:n.clone(),startControlPoint2:i.clone(),divider:s.clone(),dividerControlPoint1:s.clone(),dividerControlPoint2:s.clone()};const r=new o(e,n).pointAt(t),h=new o(n,i).pointAt(t),l=new o(i,s).pointAt(t),u=new o(r,h).pointAt(t),a=new o(h,l).pointAt(t);return{startControlPoint1:r,startControlPoint2:u,divider:new o(u,a).pointAt(t),dividerControlPoint1:a,dividerControlPoint2:l}}getSubdivisions(t={}){const e=this.getPrecision(t);let n=[new p(this.start,this.controlPoint1,this.controlPoint2,this.end)];if(0===e)return n;let i=this.endpointDistance();const s=Math.pow(10,-e);let r=0;for(;;){r+=1;const t=[];n.forEach((e=>{const n=e.divide(.5);t.push(n[0],n[1])}));const e=t.reduce(((t,e)=>t+e.endpointDistance()),0);if(r>1&&(0!==e?(e-i)/e:0)<s)return t;n=t,i=e}}length(t={}){return this.getDivisions(t).reduce(((t,e)=>t+e.endpointDistance()),0)}lengthAtT(t,e={}){if(t<=0)return 0;const n=void 0===e.precision?this.PRECISION:e.precision;return this.divide(t)[0].length({precision:n})}pointAt(t,e={}){if(t<=0)return this.start.clone();if(t>=1)return this.end.clone();const n=this.tAt(t,e);return this.pointAtT(n)}pointAtLength(t,e={}){const n=this.tAtLength(t,e);return this.pointAtT(n)}pointAtT(t){return t<=0?this.start.clone():t>=1?this.end.clone():this.getSkeletonPoints(t).divider}isDifferentiable(){const t=this.start,e=this.controlPoint1,n=this.controlPoint2,i=this.end;return!(t.equals(e)&&e.equals(n)&&n.equals(i))}tangentAt(t,e={}){if(!this.isDifferentiable())return null;t<0?t=0:t>1&&(t=1);const n=this.tAt(t,e);return this.tangentAtT(n)}tangentAtLength(t,e={}){if(!this.isDifferentiable())return null;const n=this.tAtLength(t,e);return this.tangentAtT(n)}tangentAtT(t){if(!this.isDifferentiable())return null;t<0&&(t=0),t>1&&(t=1);const e=this.getSkeletonPoints(t),n=e.startControlPoint2,i=e.dividerControlPoint1,s=e.divider,r=new o(n,i);return r.translate(s.x-n.x,s.y-n.y),r}getPrecision(t={}){return null==t.precision?this.PRECISION:t.precision}getDivisions(t={}){if(null!=t.subdivisions)return t.subdivisions;const e=this.getPrecision(t);return this.getSubdivisions({precision:e})}getOptions(t={}){return{precision:this.getPrecision(t),subdivisions:this.getDivisions(t)}}tAt(t,e={}){if(t<=0)return 0;if(t>=1)return 1;const n=this.getOptions(e),i=this.length(n)*t;return this.tAtLength(i,n)}tAtLength(t,e={}){let n=!0;t<0&&(n=!1,t=-t);const i=this.getPrecision(e),s=this.getDivisions(e),r={precision:i,subdivisions:s};let o,h,l=null,u=0,a=0,c=0;const g=s.length;let d=g>0?1/g:0;for(let e=0;e<g;e+=1){const i=n?e:g-1-e,r=s[e],f=r.endpointDistance();if(t<=c+f){l=r,o=i*d,h=(i+1)*d,u=n?t-c:f+c-t,a=n?f+c-t:t-c;break}c+=f}if(null==l)return n?1:0;const f=this.length(r),p=Math.pow(10,-i);for(;;){let t,e,n;if(t=0!==f?u/f:0,t<p)return o;if(t=0!==f?a/f:0,t<p)return h;const i=l.divide(.5);d/=2;const s=i[0].endpointDistance(),r=i[1].endpointDistance();u<=s?(l=i[0],h-=d,e=u,n=s-e):(l=i[1],o+=d,e=u-s,n=r-e),u=e,a=n}}toPoints(t={}){const e=this.getDivisions(t),n=[e[0].start.clone()];return e.forEach((t=>n.push(t.end.clone()))),n}toPolyline(t={}){return new f(this.toPoints(t))}scale(t,e,n){return this.start.scale(t,e,n),this.controlPoint1.scale(t,e,n),this.controlPoint2.scale(t,e,n),this.end.scale(t,e,n),this}rotate(t,e){return this.start.rotate(t,e),this.controlPoint1.rotate(t,e),this.controlPoint2.rotate(t,e),this.end.rotate(t,e),this}translate(t,e){return"number"==typeof t?(this.start.translate(t,e),this.controlPoint1.translate(t,e),this.controlPoint2.translate(t,e),this.end.translate(t,e)):(this.start.translate(t),this.controlPoint1.translate(t),this.controlPoint2.translate(t),this.end.translate(t)),this}equals(t){return null!=t&&this.start.equals(t.start)&&this.controlPoint1.equals(t.controlPoint1)&&this.controlPoint2.equals(t.controlPoint2)&&this.end.equals(t.end)}clone(){return new p(this.start,this.controlPoint1,this.controlPoint2,this.end)}toJSON(){return{start:this.start.toJSON(),controlPoint1:this.controlPoint1.toJSON(),controlPoint2:this.controlPoint2.toJSON(),end:this.end.toJSON()}}serialize(){return[this.start.serialize(),this.controlPoint1.serialize(),this.controlPoint2.serialize(),this.end.serialize()].join(" ")}}!function(t){t.isCurve=function(e){return null!=e&&e instanceof t}}(p||(p={})),function(t){function e(t){const e=t.length,n=[],i=[];let s=2;n[0]=t[0]/s;for(let r=1;r<e;r+=1)i[r]=1/s,s=(r<e-1?4:3.5)-i[r],n[r]=(t[r]-n[r-1])/s;for(let t=1;t<e;t+=1)n[e-t-1]-=i[e-t]*n[e-t];return n}t.throughPoints=function(n){if(null==n||Array.isArray(n)&&n.length<2)throw new Error("At least 2 points are required");const i=function(t){const n=t.map((t=>s.clone(t))),i=[],r=[],o=n.length-1;if(1===o)return i[0]=new s((2*n[0].x+n[1].x)/3,(2*n[0].y+n[1].y)/3),r[0]=new s(2*i[0].x-n[0].x,2*i[0].y-n[0].y),[i,r];const h=[];for(let t=1;t<o-1;t+=1)h[t]=4*n[t].x+2*n[t+1].x;h[0]=n[0].x+2*n[1].x,h[o-1]=(8*n[o-1].x+n[o].x)/2;const l=e(h);for(let t=1;t<o-1;t+=1)h[t]=4*n[t].y+2*n[t+1].y;h[0]=n[0].y+2*n[1].y,h[o-1]=(8*n[o-1].y+n[o].y)/2;const u=e(h);for(let t=0;t<o;t+=1)i.push(new s(l[t],u[t])),t<o-1?r.push(new s(2*n[t+1].x-l[t+1],2*n[t+1].y-u[t+1])):r.push(new s((n[o].x+l[o-1])/2,(n[o].y+u[o-1])/2));return[i,r]}(n),r=[];for(let e=0,o=i[0].length;e<o;e+=1){const o=new s(i[0][e].x,i[0][e].y),h=new s(i[1][e].x,i[1][e].y);r.push(new t(n[e],o,h,n[e+1]))}return r}}(p||(p={}));class y extends i{constructor(){super(...arguments),this.isVisible=!0,this.isSegment=!0,this.isSubpathStart=!1}get end(){return this.endPoint}get start(){if(null==this.previousSegment)throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");return this.previousSegment.end}closestPointT(t,e){if(this.closestPointNormalizedLength)return this.closestPointNormalizedLength(t);throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.")}lengthAtT(t,e){if(t<=0)return 0;const n=this.length();return t>=1?n:n*t}divideAtT(t){if(this.divideAt)return this.divideAt(t);throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.")}pointAtT(t){if(this.pointAt)return this.pointAt(t);throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.")}tangentAtT(t){if(this.tangentAt)return this.tangentAt(t);throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.")}}class m extends y{constructor(t,e){super(),o.isLine(t)?this.endPoint=t.end.clone().round(2):this.endPoint=s.create(t,e).round(2)}get type(){return"L"}get line(){return new o(this.start,this.end)}bbox(){return this.line.bbox()}closestPoint(t){return this.line.closestPoint(t)}closestPointLength(t){return this.line.closestPointLength(t)}closestPointNormalizedLength(t){return this.line.closestPointNormalizedLength(t)}closestPointTangent(t){return this.line.closestPointTangent(t)}length(){return this.line.length()}divideAt(t){const e=this.line.divideAt(t);return[new m(e[0]),new m(e[1])]}divideAtLength(t){const e=this.line.divideAtLength(t);return[new m(e[0]),new m(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.line.pointAt(t)}pointAtLength(t){return this.line.pointAtLength(t)}tangentAt(t){return this.line.tangentAt(t)}tangentAtLength(t){return this.line.tangentAtLength(t)}isDifferentiable(){return null!=this.previousSegment&&!this.start.equals(this.end)}clone(){return new m(this.end)}scale(t,e,n){return this.end.scale(t,e,n),this}rotate(t,e){return this.end.rotate(t,e),this}translate(t,e){return"number"==typeof t?this.end.translate(t,e):this.end.translate(t),this}equals(t){return this.type===t.type&&this.start.equals(t.start)&&this.end.equals(t.end)}toJSON(){return{type:this.type,start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){const t=this.end;return`${this.type} ${t.x} ${t.y}`}}!function(t){t.create=function(...e){const n=e.length,i=e[0];if(o.isLine(i))return new t(i);if(s.isPointLike(i))return 1===n?new t(i):e.map((e=>new t(e)));if(2===n)return new t(+e[0],+e[1]);const r=[];for(let i=0;i<n;i+=2){const n=+e[i],s=+e[i+1];r.push(new t(n,s))}return r}}(m||(m={}));class x extends y{get end(){if(!this.subpathStartSegment)throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");return this.subpathStartSegment.end}get type(){return"Z"}get line(){return new o(this.start,this.end)}bbox(){return this.line.bbox()}closestPoint(t){return this.line.closestPoint(t)}closestPointLength(t){return this.line.closestPointLength(t)}closestPointNormalizedLength(t){return this.line.closestPointNormalizedLength(t)}closestPointTangent(t){return this.line.closestPointTangent(t)}length(){return this.line.length()}divideAt(t){const e=this.line.divideAt(t);return[e[1].isDifferentiable()?new m(e[0]):this.clone(),new m(e[1])]}divideAtLength(t){const e=this.line.divideAtLength(t);return[e[1].isDifferentiable()?new m(e[0]):this.clone(),new m(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.line.pointAt(t)}pointAtLength(t){return this.line.pointAtLength(t)}tangentAt(t){return this.line.tangentAt(t)}tangentAtLength(t){return this.line.tangentAtLength(t)}isDifferentiable(){return!(!this.previousSegment||!this.subpathStartSegment)&&!this.start.equals(this.end)}scale(){return this}rotate(){return this}translate(){return this}equals(t){return this.type===t.type&&this.start.equals(t.start)&&this.end.equals(t.end)}clone(){return new x}toJSON(){return{type:this.type,start:this.start.toJSON(),end:this.end.toJSON()}}serialize(){return this.type}}!function(t){t.create=function(){return new t}}(x||(x={}));class w extends y{constructor(t,e){super(),this.isVisible=!1,this.isSubpathStart=!0,o.isLine(t)||p.isCurve(t)?this.endPoint=t.end.clone().round(2):this.endPoint=s.create(t,e).round(2)}get start(){throw new Error("Illegal access. Moveto segments should not need a start property.")}get type(){return"M"}bbox(){return null}closestPoint(){return this.end.clone()}closestPointLength(){return 0}closestPointNormalizedLength(){return 0}closestPointT(){return 1}closestPointTangent(){return null}length(){return 0}lengthAtT(){return 0}divideAt(){return[this.clone(),this.clone()]}divideAtLength(){return[this.clone(),this.clone()]}getSubdivisions(){return[]}pointAt(){return this.end.clone()}pointAtLength(){return this.end.clone()}pointAtT(){return this.end.clone()}tangentAt(){return null}tangentAtLength(){return null}tangentAtT(){return null}isDifferentiable(){return!1}scale(t,e,n){return this.end.scale(t,e,n),this}rotate(t,e){return this.end.rotate(t,e),this}translate(t,e){return"number"==typeof t?this.end.translate(t,e):this.end.translate(t),this}clone(){return new w(this.end)}equals(t){return this.type===t.type&&this.end.equals(t.end)}toJSON(){return{type:this.type,end:this.end.toJSON()}}serialize(){const t=this.end;return`${this.type} ${t.x} ${t.y}`}}!function(t){t.create=function(...e){const n=e.length,i=e[0];if(o.isLine(i))return new t(i);if(p.isCurve(i))return new t(i);if(s.isPointLike(i)){if(1===n)return new t(i);const s=[];for(let i=0;i<n;i+=1)0===i?s.push(new t(e[i])):s.push(new m(e[i]));return s}if(2===n)return new t(+e[0],+e[1]);const r=[];for(let i=0;i<n;i+=2){const n=+e[i],s=+e[i+1];0===i?r.push(new t(n,s)):r.push(new m(n,s))}return r}}(w||(w={}));class P extends y{constructor(t,e,n,i,r,o){super(),p.isCurve(t)?(this.controlPoint1=t.controlPoint1.clone().round(2),this.controlPoint2=t.controlPoint2.clone().round(2),this.endPoint=t.end.clone().round(2)):"number"==typeof t?(this.controlPoint1=new s(t,e).round(2),this.controlPoint2=new s(n,i).round(2),this.endPoint=new s(r,o).round(2)):(this.controlPoint1=s.create(t).round(2),this.controlPoint2=s.create(e).round(2),this.endPoint=s.create(n).round(2))}get type(){return"C"}get curve(){return new p(this.start,this.controlPoint1,this.controlPoint2,this.end)}bbox(){return this.curve.bbox()}closestPoint(t){return this.curve.closestPoint(t)}closestPointLength(t){return this.curve.closestPointLength(t)}closestPointNormalizedLength(t){return this.curve.closestPointNormalizedLength(t)}closestPointTangent(t){return this.curve.closestPointTangent(t)}length(){return this.curve.length()}divideAt(t,e={}){const n=this.curve.divideAt(t,e);return[new P(n[0]),new P(n[1])]}divideAtLength(t,e={}){const n=this.curve.divideAtLength(t,e);return[new P(n[0]),new P(n[1])]}divideAtT(t){const e=this.curve.divideAtT(t);return[new P(e[0]),new P(e[1])]}getSubdivisions(){return[]}pointAt(t){return this.curve.pointAt(t)}pointAtLength(t){return this.curve.pointAtLength(t)}tangentAt(t){return this.curve.tangentAt(t)}tangentAtLength(t){return this.curve.tangentAtLength(t)}isDifferentiable(){if(!this.previousSegment)return!1;const t=this.start,e=this.controlPoint1,n=this.controlPoint2,i=this.end;return!(t.equals(e)&&e.equals(n)&&n.equals(i))}scale(t,e,n){return this.controlPoint1.scale(t,e,n),this.controlPoint2.scale(t,e,n),this.end.scale(t,e,n),this}rotate(t,e){return this.controlPoint1.rotate(t,e),this.controlPoint2.rotate(t,e),this.end.rotate(t,e),this}translate(t,e){return"number"==typeof t?(this.controlPoint1.translate(t,e),this.controlPoint2.translate(t,e),this.end.translate(t,e)):(this.controlPoint1.translate(t),this.controlPoint2.translate(t),this.end.translate(t)),this}equals(t){return this.start.equals(t.start)&&this.end.equals(t.end)&&this.controlPoint1.equals(t.controlPoint1)&&this.controlPoint2.equals(t.controlPoint2)}clone(){return new P(this.controlPoint1,this.controlPoint2,this.end)}toJSON(){return{type:this.type,start:this.start.toJSON(),controlPoint1:this.controlPoint1.toJSON(),controlPoint2:this.controlPoint2.toJSON(),end:this.end.toJSON()}}serialize(){const t=this.controlPoint1,e=this.controlPoint2,n=this.end;return[this.type,t.x,t.y,e.x,e.y,n.x,n.y].join(" ")}}function b(t,e,n){return{x:t*Math.cos(n)-e*Math.sin(n),y:t*Math.sin(n)+e*Math.cos(n)}}function A(t,e,n,i,s,r){const o=1/3,h=2/3;return[o*t+h*n,o*e+h*i,o*s+h*n,o*r+h*i,s,r]}function S(t,e,n,i,s,r,o,h,l,u){const a=120*Math.PI/180,c=Math.PI/180*(+s||0);let g,d,f,p,y,m=[];if(u)d=u[0],f=u[1],p=u[2],y=u[3];else{g=b(t,e,-c),t=g.x,e=g.y,g=b(h,l,-c);const s=(t-(h=g.x))/2,u=(e-(l=g.y))/2;let a=s*s/(n*n)+u*u/(i*i);a>1&&(a=Math.sqrt(a),n*=a,i*=a);const m=n*n,x=i*i,w=(r===o?-1:1)*Math.sqrt(Math.abs((m*x-m*u*u-x*s*s)/(m*u*u+x*s*s)));p=w*n*u/i+(t+h)/2,y=w*-i*s/n+(e+l)/2,d=Math.asin((e-y)/i),f=Math.asin((l-y)/i),d=t<p?Math.PI-d:d,f=h<p?Math.PI-f:f,d<0&&(d=2*Math.PI+d),f<0&&(f=2*Math.PI+f),o&&d>f&&(d-=2*Math.PI),!o&&f>d&&(f-=2*Math.PI)}let x=f-d;if(Math.abs(x)>a){const t=f,e=h,r=l;f=d+a*(o&&f>d?1:-1),m=S(h=p+n*Math.cos(f),l=y+i*Math.sin(f),n,i,s,0,o,e,r,[f,t,p,y])}x=f-d;const w=Math.cos(d),P=Math.sin(d),A=Math.cos(f),v=Math.sin(f),L=Math.tan(x/4),M=4/3*(n*L),T=4/3*(i*L),N=[t,e],q=[t+M*P,e-T*w],C=[h+M*v,l-T*A],z=[h,l];if(q[0]=2*N[0]-q[0],q[1]=2*N[1]-q[1],u)return[q,C,z].concat(m);{m=[q,C,z].concat(m).join().split(",");const t=[],e=m.length;for(let n=0;n<e;n+=1)t[n]=n%2?b(+m[n-1],+m[n],c).y:b(+m[n],+m[n+1],c).x;return t}}function v(t){const e=function(t){if(!t)return null;const e="\t\n\v\f\r   ᠎             　\u2028\u2029",n=new RegExp(`([a-z])[${e},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${e}]*,?[${e}]*)+)`,"ig"),i=new RegExp(`(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${e}]*,?[${e}]*`,"ig"),s={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},r=[];return t.replace(n,((t,e,n)=>{const o=[];let h=e.toLowerCase();n.replace(i,((t,e)=>(e&&o.push(+e),t))),"m"===h&&o.length>2&&(r.push([e,...o.splice(0,2)]),h="l",e="m"===e?"l":"L");const l=s[h];for(;o.length>=l&&(r.push([e,...o.splice(0,l)]),l););return t})),r}(t);if(!e||!e.length)return[["M",0,0]];let n=0,i=0,s=0,r=0;const o=[];for(let t=0,h=e.length;t<h;t+=1){const h=[];o.push(h);const l=e[t],u=l[0];if(u!==u.toUpperCase())switch(h[0]=u.toUpperCase(),h[0]){case"A":h[1]=l[1],h[2]=l[2],h[3]=l[3],h[4]=l[4],h[5]=l[5],h[6]=+l[6]+n,h[7]=+l[7]+i;break;case"V":h[1]=+l[1]+i;break;case"H":h[1]=+l[1]+n;break;case"M":s=+l[1]+n,r=+l[2]+i;for(let t=1,e=l.length;t<e;t+=1)h[t]=+l[t]+(t%2?n:i);break;default:for(let t=1,e=l.length;t<e;t+=1)h[t]=+l[t]+(t%2?n:i)}else for(let t=0,e=l.length;t<e;t+=1)h[t]=l[t];switch(h[0]){case"Z":n=+s,i=+r;break;case"H":n=h[1];break;case"V":i=h[1];break;case"M":s=h[h.length-2],r=h[h.length-1],n=h[h.length-2],i=h[h.length-1];break;default:n=h[h.length-2],i=h[h.length-1]}}return o}function L(t){const e=v(t),n={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null};function i(t,e,n){let i,s;if(!t)return["C",e.x,e.y,e.x,e.y,e.x,e.y];switch(t[0]in{T:1,Q:1}||(e.qx=null,e.qy=null),t[0]){case"M":e.X=t[1],e.Y=t[2];break;case"A":return 0===parseFloat(t[1])||0===parseFloat(t[2])?["L",t[6],t[7]]:["C"].concat(S.apply(0,[e.x,e.y].concat(t.slice(1))));case"S":return"C"===n||"S"===n?(i=2*e.x-e.bx,s=2*e.y-e.by):(i=e.x,s=e.y),["C",i,s].concat(t.slice(1));case"T":return"Q"===n||"T"===n?(e.qx=2*e.x-e.qx,e.qy=2*e.y-e.qy):(e.qx=e.x,e.qy=e.y),["C"].concat(A(e.x,e.y,e.qx,e.qy,t[1],t[2]));case"Q":return e.qx=t[1],e.qy=t[2],["C"].concat(A(e.x,e.y,t[1],t[2],t[3],t[4]));case"H":return["L"].concat(t[1],e.y);case"V":return["L"].concat(e.x,t[1])}return t}function s(t,n){if(t[n].length>7){t[n].shift();const i=t[n];for(;i.length;)r[n]="A",n+=1,t.splice(n,0,["C"].concat(i.splice(0,6)));t.splice(n,1),h=e.length}}const r=[];let o="",h=e.length;for(let t=0;t<h;t+=1){let h="";e[t]&&(h=e[t][0]),"C"!==h&&(r[t]=h,t>0&&(o=r[t-1])),e[t]=i(e[t],n,o),"A"!==r[t]&&"C"===h&&(r[t]="C"),s(e,t);const l=e[t],u=l.length;n.x=l[u-2],n.y=l[u-1],n.bx=parseFloat(l[u-4])||n.x,n.by=parseFloat(l[u-3])||n.y}return e[0][0]&&"M"===e[0][0]||e.unshift(["M",0,0]),e}function M(e){return L(e).map((e=>e.map((e=>"string"==typeof e?e:t.GeometryUtil.round(e,2))))).join(",").split(",").join(" ")}!function(t){t.create=function(...e){const n=e.length,i=e[0];if(p.isCurve(i))return new t(i);if(s.isPointLike(i)){if(3===n)return new t(e[0],e[1],e[2]);const i=[];for(let s=0;s<n;s+=3)i.push(new t(e[s],e[s+1],e[s+2]));return i}if(6===n)return new t(e[0],e[1],e[2],e[3],e[4],e[5]);const r=[];for(let i=0;i<n;i+=6)r.push(new t(e[i],e[i+1],e[i+2],e[i+3],e[i+4],e[i+5]));return r}}(P||(P={}));class T extends i{constructor(t){if(super(),this.PRECISION=3,this.segments=[],Array.isArray(t))if(o.isLine(t[0])||p.isCurve(t[0])){let e=null;t.forEach(((t,n)=>{0===n&&this.appendSegment(T.createSegment("M",t.start)),null==e||e.end.equals(t.start)||this.appendSegment(T.createSegment("M",t.start)),o.isLine(t)?this.appendSegment(T.createSegment("L",t.end)):p.isCurve(t)&&this.appendSegment(T.createSegment("C",t.controlPoint1,t.controlPoint2,t.end)),e=t}))}else{t.forEach((t=>{t.isSegment&&this.appendSegment(t)}))}else null!=t&&(o.isLine(t)?(this.appendSegment(T.createSegment("M",t.start)),this.appendSegment(T.createSegment("L",t.end))):p.isCurve(t)?(this.appendSegment(T.createSegment("M",t.start)),this.appendSegment(T.createSegment("C",t.controlPoint1,t.controlPoint2,t.end))):f.isPolyline(t)?t.points&&t.points.length&&t.points.forEach(((t,e)=>{const n=0===e?T.createSegment("M",t):T.createSegment("L",t);this.appendSegment(n)})):t.isSegment&&this.appendSegment(t))}get start(){const t=this.segments,e=t.length;if(0===e)return null;for(let n=0;n<e;n+=1){const e=t[n];if(e.isVisible)return e.start}return t[e-1].end}get end(){const t=this.segments,e=t.length;if(0===e)return null;for(let n=e-1;n>=0;n-=1){const e=t[n];if(e.isVisible)return e.end}return t[e-1].end}moveTo(...t){return this.appendSegment(w.create.call(null,...t))}lineTo(...t){return this.appendSegment(m.create.call(null,...t))}curveTo(...t){return this.appendSegment(P.create.call(null,...t))}arcTo(t,e,n,i,r,o,h){const l=this.end||new s,u="number"==typeof o?g(l.x,l.y,t,e,n,i,r,o,h):g(l.x,l.y,t,e,n,i,r,o.x,o.y);if(null!=u)for(let t=0,e=u.length;t<e;t+=6)this.curveTo(u[t],u[t+1],u[t+2],u[t+3],u[t+4],u[t+5]);return this}quadTo(t,e,n,i){const r=this.end||new s,o=["M",r.x,r.y];if("number"==typeof t)o.push("Q",t,e,n,i);else{const n=e;o.push("Q",t.x,t.y,n.x,n.y)}const h=T.parse(o.join(" "));return this.appendSegment(h.segments.slice(1)),this}close(){return this.appendSegment(x.create())}drawPoints(t,e={}){const n=c(t,e),i=T.parse(n);i&&i.segments&&this.appendSegment(i.segments)}bbox(){const t=this.segments,e=t.length;if(0===e)return null;let n;for(let i=0;i<e;i+=1){const e=t[i];if(e.isVisible){const t=e.bbox();null!=t&&(n=n?n.union(t):t)}}if(null!=n)return n;const i=t[e-1];return new r(i.end.x,i.end.y,0,0)}appendSegment(t){const e=this.segments.length;let n,i=0!==e?this.segments[e-1]:null;if(Array.isArray(t))for(let e=0,s=t.length;e<s;e+=1){const s=t[e];n=this.prepareSegment(s,i,null),this.segments.push(n),i=n}else null!=t&&t.isSegment&&(n=this.prepareSegment(t,i,null),this.segments.push(n));return this}insertSegment(t,e){const n=this.segments.length;if(t<0&&(t=n+t+1),t>n||t<0)throw new Error("Index out of range.");let i,s=null,r=null;if(0!==n&&(t>=1?(s=this.segments[t-1],r=s.nextSegment):(s=null,r=this.segments[0])),Array.isArray(e))for(let n=0,o=e.length;n<o;n+=1){const o=e[n];i=this.prepareSegment(o,s,r),this.segments.splice(t+n,0,i),s=i}else i=this.prepareSegment(e,s,r),this.segments.splice(t,0,i);return this}removeSegment(t){const e=this.fixIndex(t),n=this.segments.splice(e,1)[0],i=n.previousSegment,s=n.nextSegment;return i&&(i.nextSegment=s),s&&(s.previousSegment=i),n.isSubpathStart&&s&&this.updateSubpathStartSegment(s),n}replaceSegment(t,e){const n=this.fixIndex(t);let i;const s=this.segments[n];let r=s.previousSegment;const o=s.nextSegment;let h=s.isSubpathStart;if(Array.isArray(e)){this.segments.splice(t,1);for(let n=0,s=e.length;n<s;n+=1){const s=e[n];i=this.prepareSegment(s,r,o),this.segments.splice(t+n,0,i),r=i,h&&i.isSubpathStart&&(h=!1)}}else i=this.prepareSegment(e,r,o),this.segments.splice(n,1,i),h&&i.isSubpathStart&&(h=!1);h&&o&&this.updateSubpathStartSegment(o)}getSegment(t){const e=this.fixIndex(t);return this.segments[e]}fixIndex(t){const e=this.segments.length;if(0===e)throw new Error("Path has no segments.");let n=t;for(;n<0;)n=e+n;if(n>=e||n<0)throw new Error("Index out of range.");return n}segmentAt(t,e={}){const n=this.segmentIndexAt(t,e);return n?this.getSegment(n):null}segmentAtLength(t,e={}){const n=this.segmentIndexAtLength(t,e);return n?this.getSegment(n):null}segmentIndexAt(e,n={}){if(0===this.segments.length)return null;const i=t.GeometryUtil.clamp(e,0,1),s=this.getOptions(n),r=this.length(s)*i;return this.segmentIndexAtLength(r,s)}segmentIndexAtLength(t,e={}){const n=this.segments.length;if(0===n)return null;let i=!0;t<0&&(i=!1,t=-t);const s=this.getPrecision(e),r=this.getSubdivisions(e);let o=0,h=null;for(let e=0;e<n;e+=1){const l=i?e:n-1-e,u=this.segments[l],a=r[l],c=u.length({precision:s,subdivisions:a});if(u.isVisible){if(t<=o+c)return l;h=l}o+=c}return h}getSegmentSubdivisions(t={}){const e=this.getPrecision(t),n=[];for(let t=0,i=this.segments.length;t<i;t+=1){const i=this.segments[t].getSubdivisions({precision:e});n.push(i)}return n}updateSubpathStartSegment(t){let e=t.previousSegment,n=t;for(;n&&!n.isSubpathStart;)n.subpathStartSegment=null!=e?e.subpathStartSegment:null,e=n,n=n.nextSegment}prepareSegment(t,e,n){t.previousSegment=e,t.nextSegment=n,null!=e&&(e.nextSegment=t),null!=n&&(n.previousSegment=t);let i=t;return t.isSubpathStart&&(t.subpathStartSegment=t,i=n),null!=i&&this.updateSubpathStartSegment(i),t}closestPoint(t,e={}){const n=this.closestPointT(t,e);return n?this.pointAtT(n):null}closestPointLength(t,e={}){const n=this.getOptions(e),i=this.closestPointT(t,n);return i?this.lengthAtT(i,n):0}closestPointNormalizedLength(t,e={}){const n=this.getOptions(e),i=this.closestPointLength(t,n);if(0===i)return 0;const s=this.length(n);return 0===s?0:i/s}closestPointT(e,n={}){if(0===this.segments.length)return null;const i=this.getPrecision(n),s=this.getSubdivisions(n);let r,o=1/0;for(let n=0,h=this.segments.length;n<h;n+=1){const h=this.segments[n],l=s[n];if(h.isVisible){const s=h.closestPointT(e,{precision:i,subdivisions:l}),u=h.pointAtT(s),a=t.GeometryUtil.squaredLength(u,e);a<o&&(r={segmentIndex:n,value:s},o=a)}}return r||{segmentIndex:this.segments.length-1,value:1}}closestPointTangent(e,n={}){if(0===this.segments.length)return null;const i=this.getPrecision(n),s=this.getSubdivisions(n);let r,o=1/0;for(let n=0,h=this.segments.length;n<h;n+=1){const h=this.segments[n],l=s[n];if(h.isDifferentiable()){const n=h.closestPointT(e,{precision:i,subdivisions:l}),s=h.pointAtT(n),u=t.GeometryUtil.squaredLength(s,e);u<o&&(r=h.tangentAtT(n),o=u)}}return r||null}containsPoint(t,e={}){const n=this.toPolylines(e);if(!n)return!1;let i=0;for(let e=0,s=n.length;e<s;e+=1){n[e].containsPoint(t)&&(i+=1)}return i%2==1}pointAt(t,e={}){if(0===this.segments.length)return null;if(t<=0)return this.start.clone();if(t>=1)return this.end.clone();const n=this.getOptions(e),i=this.length(n)*t;return this.pointAtLength(i,n)}pointAtLength(t,e={}){if(0===this.segments.length)return null;if(0===t)return this.start.clone();let n=!0;t<0&&(n=!1,t=-t);const i=this.getPrecision(e),s=this.getSubdivisions(e);let r,o=0;for(let e=0,h=this.segments.length;e<h;e+=1){const l=n?e:h-1-e,u=this.segments[l],a=s[l],c=u.length({precision:i,subdivisions:a});if(u.isVisible){if(t<=o+c)return u.pointAtLength((n?1:-1)*(t-o),{precision:i,subdivisions:a});r=u}o+=c}if(r)return n?r.end:r.start;return this.segments[this.segments.length-1].end.clone()}pointAtT(e){const n=this.segments,i=n.length;if(0===i)return null;const s=e.segmentIndex;if(s<0)return n[0].pointAtT(0);if(s>=i)return n[i-1].pointAtT(1);const r=t.GeometryUtil.clamp(e.value,0,1);return n[s].pointAtT(r)}divideAt(e,n={}){if(0===this.segments.length)return null;const i=t.GeometryUtil.clamp(e,0,1),s=this.getOptions(n),r=this.length(s)*i;return this.divideAtLength(r,s)}divideAtLength(t,e={}){if(0===this.segments.length)return null;let n=!0;t<0&&(n=!1,t=-t);const i=this.getPrecision(e),s=this.getSubdivisions(e);let r,o,h,l,u,a=0;for(let e=0,u=this.segments.length;e<u;e+=1){const c=n?e:u-1-e,g=this.getSegment(c),d={precision:i,subdivisions:s[c]},f=g.length(d);if(g.isDifferentiable()&&(h=g,l=c,t<=a+f)){o=c,r=g.divideAtLength((n?1:-1)*(t-a),d);break}a+=f}if(!h)return null;r||(o=l,u=n?1:0,r=h.divideAtT(u));const c=this.clone(),g=o;c.replaceSegment(g,r);const d=g;let f=g+1,p=g+2;r[0].isDifferentiable()||(c.removeSegment(d),f-=1,p-=1);const y=c.getSegment(f).start;c.insertSegment(f,T.createSegment("M",y)),p+=1,r[1].isDifferentiable()||(c.removeSegment(p-1),p-=1);const m=p-d-1;for(let t=p,e=c.segments.length;t<e;t+=1){const e=this.getSegment(t-m),n=c.getSegment(t);if("Z"===n.type&&!e.subpathStartSegment.end.equals(n.subpathStartSegment.end)){const n=T.createSegment("L",e.end);c.replaceSegment(t,n)}}return[new T(c.segments.slice(0,f)),new T(c.segments.slice(f))]}intersectsWithLine(t,e={}){const n=this.toPolylines(e);if(null==n)return null;let i=null;for(let e=0,s=n.length;e<s;e+=1){const s=n[e],r=t.intersect(s);r&&(null==i&&(i=[]),Array.isArray(r)?i.push(...r):i.push(r))}return i}isDifferentiable(){for(let t=0,e=this.segments.length;t<e;t+=1){if(this.segments[t].isDifferentiable())return!0}return!1}isValid(){const t=this.segments;return 0===t.length||"M"===t[0].type}length(t={}){if(0===this.segments.length)return 0;const e=this.getSubdivisions(t);let n=0;for(let t=0,i=this.segments.length;t<i;t+=1){const i=this.segments[t],s=e[t];n+=i.length({subdivisions:s})}return n}lengthAtT(e,n={}){const i=this.segments.length;if(0===i)return 0;let s=e.segmentIndex;if(s<0)return 0;let r=t.GeometryUtil.clamp(e.value,0,1);s>=i&&(s=i-1,r=1);const o=this.getPrecision(n),h=this.getSubdivisions(n);let l=0;for(let t=0;t<s;t+=1){const e=this.segments[t],n=h[t];l+=e.length({precision:o,subdivisions:n})}const u=this.segments[s],a=h[s];return l+=u.lengthAtT(r,{precision:o,subdivisions:a}),l}tangentAt(e,n={}){if(0===this.segments.length)return null;const i=t.GeometryUtil.clamp(e,0,1),s=this.getOptions(n),r=this.length(s)*i;return this.tangentAtLength(r,s)}tangentAtLength(t,e={}){if(0===this.segments.length)return null;let n=!0;t<0&&(n=!1,t=-t);const i=this.getPrecision(e),s=this.getSubdivisions(e);let r,o=0;for(let e=0,h=this.segments.length;e<h;e+=1){const l=n?e:h-1-e,u=this.segments[l],a=s[l],c=u.length({precision:i,subdivisions:a});if(u.isDifferentiable()){if(t<=o+c)return u.tangentAtLength((n?1:-1)*(t-o),{precision:i,subdivisions:a});r=u}o+=c}if(r){const t=n?1:0;return r.tangentAtT(t)}return null}tangentAtT(e){const n=this.segments.length;if(0===n)return null;const i=e.segmentIndex;if(i<0)return this.segments[0].tangentAtT(0);if(i>=n)return this.segments[n-1].tangentAtT(1);const s=t.GeometryUtil.clamp(e.value,0,1);return this.segments[i].tangentAtT(s)}getPrecision(t={}){return null==t.precision?this.PRECISION:t.precision}getSubdivisions(t={}){if(null==t.segmentSubdivisions){const e=this.getPrecision(t);return this.getSegmentSubdivisions({precision:e})}return t.segmentSubdivisions}getOptions(t={}){return{precision:this.getPrecision(t),segmentSubdivisions:this.getSubdivisions(t)}}toPoints(t={}){const e=this.segments,n=e.length;if(0===n)return null;const i=this.getSubdivisions(t),s=[];let r=[];for(let t=0;t<n;t+=1){const n=e[t];if(n.isVisible){const e=i[t];e.length>0?e.forEach((t=>r.push(t.start))):r.push(n.start)}else r.length>0&&(r.push(e[t-1].end),s.push(r),r=[])}return r.length>0&&(r.push(this.end),s.push(r)),s}toPolylines(t={}){const e=this.toPoints(t);return e?e.map((t=>new f(t))):null}scale(t,e,n){return this.segments.forEach((i=>i.scale(t,e,n))),this}rotate(t,e){return this.segments.forEach((n=>n.rotate(t,e))),this}translate(t,e){return"number"==typeof t?this.segments.forEach((n=>n.translate(t,e))):this.segments.forEach((e=>e.translate(t))),this}clone(){const t=new T;return this.segments.forEach((e=>t.appendSegment(e.clone()))),t}equals(t){if(null==t)return!1;const e=this.segments,n=t.segments,i=e.length;if(n.length!==i)return!1;for(let t=0;t<i;t+=1){const i=e[t],s=n[t];if(i.type!==s.type||!i.equals(s))return!1}return!0}toJSON(){return this.segments.map((t=>t.toJSON()))}serialize(){if(!this.isValid())throw new Error("Invalid path segments.");return this.segments.map((t=>t.serialize())).join(" ")}toString(){return this.serialize()}}!function(t){t.isPath=function(e){return null!=e&&e instanceof t}}(T||(T={})),function(t){function e(t,...e){if("M"===t)return w.create.call(null,...e);if("L"===t)return m.create.call(null,...e);if("C"===t)return P.create.call(null,...e);if("z"===t||"Z"===t)return x.create();throw new Error(`Invalid path segment type "${t}"`)}t.parse=function(n){if(!n)return new t;const i=new t,s=t.normalize(n).match(/(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g);if(null!=s)for(let t=0,n=s.length;t<n;t+=1){const n=/(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g,r=s[t].match(n);if(null!=r){const t=r[0],n=r.slice(1).map((t=>+t)),s=e.call(null,t,...n);i.appendSegment(s)}}return i},t.createSegment=e}(T||(T={})),function(t){t.normalize=M,t.isValid=u,t.drawArc=d,t.drawPoints=c,t.arcToCurves=g}(T||(T={})),t.Curve=p,t.Ellipse=h,t.Line=o,t.Path=T,t.Point=s,t.Polyline=f,t.Rectangle=r,t.Segment=y,t.normalizePathData=M}));
//# sourceMappingURL=index.js.map
